<html>
<head>
	<title>Two channel heatmap</title>
	<link rel="stylesheet" type="text/css" href="../src/style.css">
</head>
<body>

<table>
	<tr>
		<td><div id = "heatmap"></div></td>
		<td>
		<table>
		<tr>
			<td>
			<div id = "cellLines">
				<b>Select cell lines to display:</b><br>
			</div>
			<div id = "drugs">
				<br>
				<b>Select drugs to display:</b><br>
			</div>
			<div id = "filter">
				<br>
				Show only drugs <br>
				with deltaDSS at least 
				<input type = "number" id = "dss_threshold" value = 5 style = "width: 50px" onchange = "change()"> <br>
				for at least 
				<input type = "number" id = "min_cell_lines" value = 6 style = "width: 50px" onchange = "change()">
				cell lines among selected<br>			
			</div>
			</td>
		</tr>
		</table>
		</td>
	</tr>
</table>

<script src = "https://d3js.org/d3.v4.min.js"></script>
<script src = "https://d3js.org/d3-scale-chromatic.v1.min.js"></script>
<script src = "https://d3js.org/d3-color.v1.min.js"></script>
<script src = "input_heatmapWithFiltering.js"></script>
<script src = "../build/d3-linked-charts.js"></script>

<script>

var cellLines = Object.keys(inputData.ctx.Alpelisib.dss.Alpelisib),
	mDrugs = Object.keys(inputData.ctx).filter(function(e) {return e != "DMSO"}),
	drugs = Object.keys(inputData.ctx.Alpelisib.dss);
//add cell line options
var chB = d3.select("#cellLines").selectAll("input")
	.data(cellLines).enter().append("div");
chB.append("input")
	.attr("type", "checkbox")
	.attr("id", function(d) {return d;})
	.attr("checked", true)
	.attr("onchange", "change()");
chB.append("label")
	.attr("for", function(d) {return d;})
	.text(function(d) {return d;});
//add drug options
var chB = d3.select("#drugs").selectAll("input")
	.data(mDrugs).enter().append("div");
chB.append("input")
	.attr("type", "checkbox")
	.attr("id", function(d) {return d;})
	.attr("checked", true)
	.attr("onchange", "change()");
chB.append("label")
	.attr("for", function(d) {return d;})
	.text(function(d) {return d;});

//check what cell lines and drugs are selected
//and create the list of column ids
var get_colIds = function(){
	//get a list of selected cell lines
	var selCL = d3.select("#cellLines").selectAll("input")
		.filter(function() {return this.checked;})
		.data();
	//get a list of selected drugs
	var selDr = d3.select("#drugs").selectAll("input")
		.filter(function() {return this.checked;})
		.data();
	//make all possible combinations
	var ids = [];
	for(var i = 0; i < selCL.length; i++)
		for(var j = 0; j < selDr.length; j++)
			ids.push(selCL[i] + "/" + selDr[j])
	return ids;
}

//check the filtering parameters and create
//the list of row ids
get_rowIds = function(){
	//get a list of selected cell lines
	var selCL = d3.select("#cellLines").selectAll("input")
		.filter(function() {return this.checked;})
		.data();
	//get a list of selected drugs
	var selDr = d3.select("#drugs").selectAll("input")
		.filter(function() {return this.checked;})
		.data();
	var min_lines = document.getElementById("min_cell_lines").value,
		thr = document.getElementById("dss_threshold").value,
		ids = [], k;
	for(var i = 0; i < drugs.length; i++){
		k = 0;
		for(var j = 0; j < selCL.length; j++)
			for(var l = 0; l < selDr.length; l++){
				if(inputData.ctx[selDr[l]].dss[drugs[i]][selCL[j]] > thr)
					k++;
				if(inputData.rtg[selDr[l]].dss[drugs[i]][selCL[j]] > thr)
					k++;
			}
		if(k >= min_lines)
			ids.push(drugs[i]);
	}

	return ids;
}

//define scales for red and green channels

var scale_red = d3.scaleLinear()
	.domain()
		
var heatmap = d3.tableChartBase()
	.width(1000)
	.height(700)
	.margin({top: 100, bottom: 50, left: 150, right: 20})
	.rowIds(d3.cache(get_rowIds))
	.colIds(d3.cache(get_colIds));
d3.heatmapChart(heatmap, "main")
	.mode("svg")
	.value(function(rowId, colId){
		var ids = colId.split("/");
		return [inputData.rtg[ids[1]].dss[rowId][ids[0]],
			inputData.ctx[ids[1]].dss[rowId][ids[0]]]
	})
	.colour(function(val){
		var self = this;
		var scale = function(val){
			if(val > self.get_colourRange()[1])
				val = self.get_colourRange()[1];
			if(val < self.get_colourRange()[0])
				val = self.get_colourRange()[0];
			return Math.round((val - self.get_colourRange()[0]) / 
				(self.get_colourRange()[1] - self.get_colourRange()[0]) * 255);
		}
		return "rgb(" + scale(val[0]) + ", " + scale(val[1]) + ", 30)";
	})
	.colourRange([0, 40]);
heatmap.place("#heatmap");

change = function(){
	heatmap.get_rowIds("clear");
	heatmap.get_colIds("clear")
	heatmap.update();
}


</script>
</body>
</html>