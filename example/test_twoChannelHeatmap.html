<html>
<head>
	<title>Two channel heatmap</title>
	<link rel="stylesheet" type="text/css" href="../src/style.css">
</head>
<body>

<table>
	<tr>
		<td><div id = "heatmap"></div></td>
		<td>
		<table>
		<tr>
			<td>
			<div id = "cellLines">
				<b>Select cell lines to display:</b><br>
			</div>
			<div id = "drugs">
				<br>
				<b>Select drugs to display:</b><br>
			</div>
			<div id = "filter">
				<br>
				Show only drugs <br>
				with deltaDSS at least 
				<input type = "number" id = "dss_threshold" value = 5 style = "width: 50px" onchange = "change()"> <br>
				for at least 
				<input type = "number" id = "min_cell_lines" value = 6 style = "width: 50px" onchange = "change()">
				cell lines among selected<br>			
			</div>
			</td>
		</tr>
		</table>
		</td>
	</tr>
	<tr>
		<td>
			<div id = "redSlider">
				Colour scale for CTX<br>
			</div>
			<div id = "greenSlider">
				Colour scale for RTG<br>
			</div>
			<p id = "test"></p>
		</td>
		<td>
			<button onclick = "heatmap.get_layer('main').clusterRows()">Cluster Rows</button><br>
			<button onclick = "heatmap.get_layer('main').clusterCols()">Cluster Columns</button>
		</td>
	</tr>
</table>

<script src = "https://d3js.org/d3.v4.min.js"></script>
<script src = "https://d3js.org/d3-scale-chromatic.v1.min.js"></script>
<script src = "https://d3js.org/d3-color.v1.min.js"></script>
<script src = "../src/lib/clusterfck.js"></script>
<script src = "input_heatmapWithFiltering.js"></script>
<script src = "../build/d3-linked-charts.js"></script>

<script>

var cellLines = Object.keys(inputData.ctx.Alpelisib.dss.Alpelisib),
	mDrugs = Object.keys(inputData.ctx).filter(function(e) {return e != "DMSO"}),
	drugs = Object.keys(inputData.ctx.Alpelisib.dss);
//add cell line options
var chB = d3.select("#cellLines").selectAll("input")
	.data(cellLines).enter().append("div");
chB.append("input")
	.attr("type", "checkbox")
	.attr("id", function(d) {return d;})
	.attr("checked", true)
	.attr("onchange", "change()");
chB.append("label")
	.attr("for", function(d) {return d;})
	.text(function(d) {return d;});
//add drug options
var chB = d3.select("#drugs").selectAll("input")
	.data(mDrugs).enter().append("div");
chB.append("input")
	.attr("type", "checkbox")
	.attr("id", function(d) {return d;})
	.attr("checked", true)
	.attr("onchange", "change()");
chB.append("label")
	.attr("for", function(d) {return d;})
	.text(function(d) {return d;});

//check what cell lines and drugs are selected
//and create the list of column ids
var get_colIds = function(){
	//get a list of selected cell lines
	var selCL = d3.select("#cellLines").selectAll("input")
		.filter(function() {return this.checked;})
		.data();
	//get a list of selected drugs
	var selDr = d3.select("#drugs").selectAll("input")
		.filter(function() {return this.checked;})
		.data();
	//make all possible combinations
	var ids = [];
	for(var i = 0; i < selCL.length; i++)
		for(var j = 0; j < selDr.length; j++)
			ids.push(selCL[i] + "/" + selDr[j])
	return ids;
}

//check the filtering parameters and create
//the list of row ids
get_rowIds = function(){
	//get a list of selected cell lines
	var selCL = d3.select("#cellLines").selectAll("input")
		.filter(function() {return this.checked;})
		.data();
	//get a list of selected drugs
	var selDr = d3.select("#drugs").selectAll("input")
		.filter(function() {return this.checked;})
		.data();
	var min_lines = document.getElementById("min_cell_lines").value,
		thr = document.getElementById("dss_threshold").value,
		ids = [], k;
	for(var i = 0; i < drugs.length; i++){
		k = 0;
		for(var j = 0; j < selCL.length; j++)
			for(var l = 0; l < selDr.length; l++){
				if(inputData.ctx[selDr[l]].dss[drugs[i]][selCL[j]] > thr)
					k++;
				if(inputData.rtg[selDr[l]].dss[drugs[i]][selCL[j]] > thr)
					k++;
			}
		if(k >= min_lines)
			ids.push(drugs[i]);
	}

	return ids;
}

var clusterMetric = function(a, b) {
	var sum = 0;
	for(var i = 0; i < a.length; i++){
		sum += (a[i][0] - b[i][0]) * (a[i][0] - b[i][0]) +
					(a[i][1] - b[i][1]) * (a[i][1] - b[i][1]);
	return Math.sqrt(sum);
	}
}

//define scales for red and green channels

var scale_red = d3.scaleLinear()
	.domain()

//add two colour sliders
var ctxSlider = d3.sigmoidColorSlider()
	.straightColorScale( d3.scaleLinear().range( [ "black", "red" ] ).domain([0, 30]) )
  .place("#redSlider");
var rtgSlider = d3.sigmoidColorSlider()
	.straightColorScale( d3.scaleLinear().range( [ "black", "green" ] ).domain([0, 30]) )
  .place("#greenSlider");
	
var heatmap = d3.tableChartBase()
	.width(1000)
	.height(700)
	.margin({top: 100, bottom: 50, left: 150, right: 20})
	.rowIds(d3.cache(get_rowIds))
	.colIds(d3.cache(get_colIds));
	
d3.heatmapChart(heatmap, "main")
	.mode("svg")
	.value(function(rowId, colId){
		var ids = colId.split("/");
		return [inputData.rtg[ids[1]].dss[rowId][ids[0]],
			inputData.ctx[ids[1]].dss[rowId][ids[0]]]
	})
	.colour(function(val){
		return "rgb(" + Math.round(ctxSlider.the_sigmoid(val[1]) * 255) + ", " 
			+ Math.round(rtgSlider.the_sigmoid(val[0]) * 255) + ", 30)";
	})
	.colourRange([0, 30])
	.clusterRowsMetric(clusterMetric)
	.clusterColsMetric(clusterMetric);
heatmap.place("#heatmap");


//change the heatmap
change = function(){
	heatmap.get_rowIds("clear");
	heatmap.get_colIds("clear")
	heatmap.update();
}

//define what happens when sliders are used
ctxSlider.last_dispatch = -Infinity
ctxSlider.on_change( function() {
	var currentTime = new Date();
  if( currentTime - ctxSlider.last_dispatch > 300 ) {
	  ctxSlider.last_dispatch = new Date();
		//heatmap.get_layer("main").updateCanvas();
    heatmap.get_layer("main").updateColour(); 
	}
});
rtgSlider.last_dispatch = -Infinity
rtgSlider.on_change( function() {
	var currentTime = new Date();
  if( currentTime - rtgSlider.last_dispatch > 300 ) {
	  rtgSlider.last_dispatch = new Date();
		//heatmap.get_layer("main").updateCanvas();
    heatmap.get_layer("main").updateColour(); 
	}
});

</script>
</body>
</html>