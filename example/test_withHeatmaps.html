<html><title>Linked charts with D3</title>

<body>
<div id = "test"></div>
<div id="main_scatter_plot"></div>

<script src="https://d3js.org/d3.v4.min.js"></script>
<script src = "input_doubleHeatmaps.js" charset="utf-8"></script>

<script>

// General chart class

function chartBase() {
  var obj = {};

  obj.add_property = function( propname ) {
    var getter = "get_" + propname;
    obj[ propname ] = function( vf ) {
      if( typeof(vf) === "function" )
        obj[ getter ] = vf
      else
        obj[ getter ] = function() { return vf };
      return obj
    }
    obj[ getter ] = function() { return undefined }
    return obj;
  }

  obj.place = function( element ) {
    if( element === undefined )
      element = "body";
    if( typeof( element ) == "string" ) {
      element = d3.select( element );
      if( element.size == 0 )
        throw "Error in function 'place': DOM selection for string '" +
          node + "' did not find a node."
    }
    obj.container = element.append( "div" )
		.style("position", "relative");
    obj.update();
    return obj;
  }
  
/*  obj.checkForSuitableContainer = function(tagName){
	if(obj.container.node().tagName != tagName){
		var c = d3.select(obj.container.node().parentNode).append(tagName);
		obj.container.remove();
		obj.container = c;
	}
  }
*/
  return obj;
}

// heatmap class

function heatmapChart(){
	var obj = chartBase()
		.add_property("nrows")
		.add_property("ncols")
		.add_property("colLabels")
		.add_property("rowLabels")
		.add_property("data")
		.add_property("palette")
		.add_property("mode")
		.add_property("height")
		.add_property("width")
		.add_property("margin");
	
	//set default parameters
	obj.mode("default");
	obj.width(1000);
	obj.height(1000);
	obj.margin({top: 100, bottom: 50, left: 100, right: 20});
	obj.colLabels(function(i) {return i;});
	obj.rowLabels(function(i) {return i;});
	
	
	obj.getRow = function(name){
		var labels = [];
		for(var i = 0; i < obj.get_nrows(); i++){
			labels.push(obj.get_rowLabels(i));
		}
		return labels.indexOf(name);
	}
	obj.getCol = function(name){
		var labels = [];
		for(var i = 0; i < obj.get_ncols(); i++){
			labels.push(obj.get_colLabels(i));
		}
		return labels.indexOf(name);
	}
	obj.getColour = function(rowName, colName){
		return obj.colourScale(obj.get_data(obj.getRow(rowName), obj.getCol(colName)));
	}
	
		
	obj.updateSVG = function() {

		var heatmapBody = obj.svg.append("g")
			.attr("class", "heatmap_body")
			.attr("transform", "translate(" + obj.get_margin().left + ", " +
				obj.get_margin().top + ")");

		//add cells	
		var cells = heatmapBody.selectAll(".datapoint").data(obj.data);
		cells.exit()
			.remove();
		cells.enter()
			.append("rect")
				.attr("class", "cell datapoint")
				.attr("width", obj.cellSize.width)
				.attr("height", obj.cellSize.height)
			.merge(cells)
				.attr("x", function(d){
					return obj.getCol(d.col) * obj.cellSize.width;
				})
				.attr("y", function(d){
					return obj.getRow(d.row) * obj.cellSize.height;
				})
				.attr("fill", function(d) {
					return obj.getColour(d.row, d.col);
				});

	}
	obj.updateCanvas = function() {
		
		var width = obj.get_width() - 
				(obj.get_margin().left + obj.get_margin().right),
			height = obj.get_height() - 
				(obj.get_margin().top + obj.get_margin().bottom);
		
		//add canvases for different parts of a chart
		obj.container.style("position", "relative");
		obj.container.style("width", obj.get_width() + "px");
		obj.container.style("height", obj.get_height() + "px");
		
		var heatmapBody = obj.container.append("canvas")
			.style("position", "absolute")
			.style("left", obj.get_margin().left + "px")
			.style("top", obj.get_margin().top + "px")
			.property("width", width)
			.property("height", height)
			.node().getContext("2d");

		//create heatmap body
		heatmapBody.clearRect(0, 0, width, height)
		for(var i = 0; i < obj.data.length; i++){
			heatmapBody.fillStyle = 
				obj.getColour(obj.data[i].row, obj.data[i].col);
			heatmapBody.fillRect(obj.getCol(obj.data[i].col) * obj.cellSize.width , 
					obj.getRow(obj.data[i].row) *  obj.cellSize.height,
					obj.getCol(obj.data[i].col) *  obj.cellSize.width + obj.cellSize.width,
					obj.getRow(obj.data[i].row) *  obj.cellSize.height + obj.cellSize.height)	
		}
		
	}
	
	obj.update = function() {
		obj.data = [];
		for(var i = 0; i < obj.get_nrows(); i++)
			for(var j = 0; j < obj.get_ncols(); j++)
				obj.data.push({
					row: obj.get_rowLabels(i),
					col: obj.get_colLabels(j),
				})
				
		//create colorScale
		obj.colourScale = d3.scaleQuantile()
			.domain(d3.extent(obj.data, function(k) {
				return obj.get_data(obj.getRow(k.row), obj.getCol(k.col));
			}))
			.range(obj.get_palette());
			
		//calculate cell size
		obj.cellSize = {
			width: (obj.get_width() - 
						(obj.get_margin().left + obj.get_margin().right))/
					obj.get_ncols(),
			height: (obj.get_height() - 
						(obj.get_margin().top + obj.get_margin().bottom))/
					obj.get_nrows()
		}
		
		obj.svg = obj.container.append("svg")
			.attr("height", obj.get_height())
			.attr("width", obj.get_width());
		
		//create main parts of the heatmap
		var colLabelsPanel = obj.svg.append("g")
			.attr("class", "label_panel")
			.attr("transform", "translate(" + obj.get_margin().left + ", " +
				obj.get_margin().top + ")");
		var rowLabelsPanel = obj.svg.append("g")
			.attr("class", "label_panel")
			.attr("transform", "translate(" + obj.get_margin().left + ", " +
				obj.get_margin().top + ")");
		var legendPanel = obj.svg.append("g")
			.attr("class", "legend_panel")
			.attr("transform", "translate(" + obj.get_margin().left + 
				", " + (obj.get_height() - obj.get_margin().bottom)  + ")");
				

		//add column labels
		var colLabels = colLabelsPanel.selectAll(".label")
				.data(d3.map(obj.data, function(e) {return e.col;}).keys());
		colLabels.exit()
			.remove();
		colLabels.enter()
			.append("text")
				.attr("class", "label")
				.attr("transform", "rotate(-90)")
				.style("text-anchor", "start")
			.merge(colLabels)
				.attr("font-size", obj.cellSize.width)
				.attr("dy", function(d) {return obj.cellSize.width * (obj.getCol(d) + 1);})
				.attr("dx", 2)
				.text(function(d) {return d});		
		
		//add row labels
		var rowLabels = rowLabelsPanel.selectAll(".label")
				.data(d3.map(obj.data, function(e) {return e.row;}).keys());
		rowLabels.exit()
			.remove();
		rowLabels.enter()
			.append("text")
				.attr("class", "label")
				.style("text-anchor", "end")
			.merge(rowLabels)
				.attr("font-size", obj.cellSize.height)
				.attr("dy", function(d) {return obj.cellSize.height * (obj.getRow(d) + 1);})
				.attr("dx", -2)
				.text(function(d) {return d});

		//add legend
		var legendStep = (obj.colourScale.domain()[1] - obj.colourScale.domain()[0]) / 
				(obj.get_palette().length - 1),
			legendScale = [], legendElementWidth = 20,
			legendElementHeight = 10;
		//if default legend elements are to wide, make them shorter
		if(legendElementWidth * obj.get_palette().length > obj.get_width())
			legendElementWidth = obj.get_width() / obj.get_palette().length;

		for(var i = 0; i < obj.get_palette().length; i++)
			legendScale.push((obj.colourScale.domain()[0] + i * legendStep).toPrecision(2));

		var legendBlocks = legendPanel.selectAll(".legend").data(legendScale);	
		legendBlocks.enter()
			.append("g")
				.attr("class", "legend")
				.attr("num", function(d, i){return i;});
		legendBlocks = legendPanel.selectAll(".legend");
		legendBlocks.append("rect");
		legendBlocks.append("text");
	
		legendBlocks
			.attr("transform", function(d, i){
				return "translate(" + legendElementWidth * i + ", 0)"
			});
		legendBlocks.selectAll("rect")
			.attr("y", legendElementHeight * 1.2)
			.attr("width", legendElementWidth)
			.attr("height", legendElementHeight)
			.attr("fill", function(){
				return obj.colourScale(d3.select(this.parentNode).datum());
			});
		legendBlocks.selectAll("text")
			.text(function() {
				if(d3.select(this.parentNode).attr("num") % 2 == 0)
					return d3.select(this.parentNode).datum();
			})
			.attr("dy", legendElementHeight * 4)
			.attr("font-size", d3.min([legendElementHeight * 1.5 - 1, legendElementWidth * 1.5]));

	
		if(obj.get_mode() == "default")
			obj.get_ncols * obj.get_nrows > 5000 ? obj.mode("canvas") : obj.mode("svg");
		if(obj.get_mode() == "canvas") {
			obj.updateCanvas();
			return obj;
		}
		if(obj.get_mode() == "svg") {
			obj.updateSVG();
			return obj;
		}
		throw "Error in function 'heatmapChart.update': mode did not correspond to any " +
			"existing type ('canvas', 'svg' or 'default')";
	}
	
	return obj;
}


//User code
heatmapChart()
	.nrows(function() {return inputData.node1.dataMatrix.length;})
	.ncols(function() {return inputData.node1.dataMatrix[0].length;})
	.colLabels(function(i) {return inputData.node1.colLabels[i];})
	.rowLabels(function(i) {return inputData.node1.rowLabels[i];})
	.data(function(i, j) {return inputData.node1.dataMatrix[i][j];})
	.palette(function() {return inputData.node1.colPalette;})
	.mode("canvas")
	.place();
	

// Not yet used:

function cache( f ) {
  var the_cache = {}
  return function( arguments ) {
    if( arguments[0] === "clear" ) {
      the_cache = {}
      return undefined;
    }
    if( !( x in keys(the_cache) ) )
      the_cache[x] = f.apply( undefined, x );
    return the_cache[x];
  }
}

//sc.get_y("clear");

</script>

</body></html>