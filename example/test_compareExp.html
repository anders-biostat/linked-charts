<html>

<title>Linked charts with D3</title>
<link rel="stylesheet" type="text/css" href="../src/style.css">
<script src = "https://d3js.org/d3.v4.min.js"></script>
<script src = "https://d3js.org/d3-scale-chromatic.v1.min.js"></script>
<script src = "https://d3js.org/d3-color.v1.min.js"></script>
<script src = "input_compareExp.js"></script>
<script src = "../build/d3-linked-charts.js"></script>

<body>
<table>
	<tr>
		<td>
			<h4 id = "mainScatterTitle" align = "center"></h4>
			<div id = "mainScatter"></div>
			<input type = "radio" value = "mean" name = "type" onchange = "switchScatter();" checked>Show mean values<br>
			<input type = "radio" value = "min"  name = "type" onchange = "switchScatter();">Show minimal values
		</td>
		<td>
			<h4 id = "cellLinesTitle" align = "center"></h4>
			<div id = "cellLines"></div>
		</td>
	</tr>
	<tr>
	<td>
		<h4 id = "curveFitTitle" align = "center"></h4>
		<div id = "curveFit"></div>
	</td>
	</tr>
</table>


<script>

function curveFunction (drug, cellLine, x) {
	var max = inputData.curveFitsP[cellLine + "_" + drug].max,
		min = inputData.curveFitsP[cellLine + "_" + drug].min,
		IC50 = inputData.curveFitsP[cellLine + "_" + drug].IC50,
		slope = inputData.curveFitsP[cellLine + "_" + drug].Slope;
		
		return min + (max - min)/(1 + Math.pow(10, -(x - Math.log10(IC50)) * slope))
}


function get_x(id){
	return inputData.meanMin[id][type + "P"];
}
function get_y(id){
	return inputData.meanMin[id][type + "B"];
}

var type = "mean";
d3.select("#mainScatterTitle")
	.text(type + " values");

var switchScatter = function(){
	var radios = document.getElementsByName('type');
	radios[0].checked ? type = "mean" : type = "min";
	d3.select("#mainScatterTitle")
		.text(type + " values");
	scatter.update();
}


//calculate colors for cell-lines plots, we'll do it just once since data are fixed
	var colorScale = d3.scaleLinear()
		.range([0, 1])
		.domain([0, 30]);	

var coloursP = {}, i_key, j_key, res, minConc, sumRes, scatterCol = {};
for(var i = 0; i < Object.keys(inputData.avInhP).length; i++){
	i_key = Object.keys(inputData.avInhP)[i];
	coloursP[i_key] = {};
	sumRes = 0;
	for(var j = 0; j < Object.keys(inputData.avInhP[i_key]).length; j++){
		j_key = Object.keys(inputData.avInhP[i_key])[j];
		res = 0;
		minConc = inputData.curveFitsP[j_key + "_" + i_key].minConc;
		for(var k = 1; k <= 5; k++){
			res += Math.pow(curveFunction(i_key, j_key, Math.log10(minConc * Math.pow(10, k - 1))) - 
							inputData.curveFitsP[j_key + "_" + i_key]["D" + k], 2);
		}
		res = Math.sqrt(res);
		sumRes += res;
		coloursP[i_key][j_key] = "rgb(" + Math.round(Math.pow(colorScale(res), 3) * 255) + ", " +  
						Math.round(80 + Math.pow((1 - colorScale(res)), 3) * 150) + "," + 
						Math.round(Math.pow(1 - colorScale(res), 3) * 150) + ")";
	}
	sumRes /= Object.keys(inputData.avInhP[i_key]).length;
	scatterCol[i_key] = "rgb(" + Math.round(Math.pow(colorScale(sumRes), 3) * 255) + ", " +  
						Math.round(80 + Math.pow((1 - colorScale(sumRes)), 3) * 150) + "," + 
						Math.round(Math.pow(1 - colorScale(sumRes), 3) * 150) + ")";
}

var selectedDrug = Object.keys(inputData.avInhP)[0];
var pCellLines = Object.keys(inputData.avInhP[selectedDrug]),
	bCellLines = Object.keys(inputData.avInhB[selectedDrug]);
var selectedCellLine = pCellLines[0];
d3.select("#cellLinesTitle")
	.text(selectedDrug);
d3.select("#curveFitTitle")
	.text(selectedDrug + " " + selectedCellLine);

var scatter = d3.scatterChart()
	.x(get_x)
	.y(get_y)
	.dataIds(Object.keys(inputData.meanMin))
	.labelX("Pancreatic cancer screening")
	.labelY("Breast cancer screening")
	.size(4)
	.colour(function(id) {
		return scatterCol[id];
	})
	.on_click(function(id){
		selectedDrug = id;
		cellLines.update();
		curveFit.update();
		curveFit.domainY("reset");
		var domain = curveFit.get_domainY();
		domain[1] = 100;
		domain[0] = d3.min([0, domain[0]]);
		curveFit.domainY(domain);
		curveFit.update();
		d3.select("#cellLinesTitle")
			.text(selectedDrug);
		d3.select("#curveFitTitle")
			.text(selectedDrug + " " + selectedCellLine);
	})
	.place("#mainScatter");

var cellLines = d3.scatterChart()
	.x(function(id){
		if(pCellLines.indexOf(id) == -1){
		 	return "Breast";
		} else{
			return "Pancreatic";
		}		
	})
	.y(function(id){
		if(pCellLines.indexOf(id) == -1){
			return inputData.avInhB[selectedDrug][id];
		} else {
			return inputData.avInhP[selectedDrug][id];
		}
	})
	.dataIds(pCellLines.concat(bCellLines))
	.labelY("Average Inhibition (%)")
	.domainY([-100, 100])
	.colour(function(id){
		return coloursP[selectedDrug][id];
	})
	.on_click(function(id){
		selectedCellLine = id;
		curveFit.update();
		curveFit.domainY("reset");
		var domain = curveFit.get_domainY();
		domain[1] = 100;
		domain[0] = d3.min([0, domain[0]]);
		curveFit.domainY(domain);
		curveFit.update();
		d3.select("#curveFitTitle")
			.text(selectedDrug + " " + selectedCellLine);
	})
	.width(300)
	.place("#cellLines");


var curveFit = d3.axisChartBase()
	.height(300)
	.labelX("Concentration (log10)")
	.labelY("Inhibition");
d3.scatterChart("scatter", curveFit)	
	.npoints(5)
	.x(function(i){
		if(bCellLines.indexOf(selectedCellLine) == -1)
			return Math.log10(inputData.curveFitsP[selectedCellLine + "_" + selectedDrug].minConc * 
							Math.pow(10, i))
		else 
			return Math.log10(inputData.curveFitsB[selectedCellLine + "_" + selectedDrug].V6 * 
							Math.pow(10, i));		
	})
	.y(function(i){
		if(bCellLines.indexOf(selectedCellLine) == -1)
			return inputData.curveFitsP[selectedCellLine + "_" + selectedDrug]["D" + (i + 1)]
		else
			return inputData.curveFitsB[selectedCellLine + "_" + selectedDrug]["V" + (i + 1)];
	});
d3.lineChart("line", curveFit)
	.nlines(function(){
		if(bCellLines.indexOf(selectedCellLine) == -1)
			return 1
		else
			return 0;
	})
	.lineFun(function(id, x){
		return curveFunction(selectedDrug, selectedCellLine, x);
	});
curveFit.place("#curveFit");

var domain = curveFit.get_domainY();
domain[1] = 100;
domain[0] = d3.min([0, domain[0]]);
curveFit.domainY(domain);
curveFit.update();

</script>

</body></html>